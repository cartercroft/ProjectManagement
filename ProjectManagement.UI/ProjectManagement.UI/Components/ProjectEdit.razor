@using ProjectManagement.Classes
@using System.Linq
@inject ProjectClient _client

<div class="project-edit-container">
    <div>
        <label>Project Name:</label>
        <InputText @bind-Value=@(Project.Name) />
    </div>
    <div class="tasks">
        @foreach (var entry in _tasksByStatus)
        {
            <div class="task-section">
                <div class="task-section-header">@entry.Key</div>
                <div class="task-list">
                    @foreach (var task in entry.Value)
                    {
                        <button type="button" class="task-detail no-style" @onclick=@(() => OpenProjectTask(task))>
                            @task.Title
                        </button>
                    }
                </div>
            </div>
        }
    </div>
    <button type="button" @onclick=@(HandleSaveClick)>Save</button>
    <button type="button" @onclick=@(HandleTaskAdd)>Add Task</button>
</div>

<TaskEditDialog @bind-Opened=@(_isTaskEditOpen) Task="_focusedTask" TaskChanged="TaskChangedCallback"></TaskEditDialog>

@code {


    [Parameter]
    public ProjectViewModel Project { get; set; } = null!;
    [Parameter]
    public Func<ProjectViewModel, Task> SaveCallback { get; set; } = null!;

    private bool _isTaskEditOpen = false;
    private ProjectTaskViewModel _focusedTask = null;

    private Dictionary<string, List<ProjectTaskViewModel>> _tasksByStatus = null!;

    protected override async Task OnInitializedAsync()
    {
        if (Project == null)
        {
            Project = new ProjectViewModel();
        }

        if (_tasksByStatus == null)
        {
            _tasksByStatus = Enum.GetValues(typeof(ProjectTaskStatus))
            .Cast<ProjectTaskStatus>()
            .ToList()
            .ToDictionary(s => s.GetDisplayNameString(),
            s => Project.Tasks.Where(t => t.Status == s).ToList());

            _tasksByStatus.Remove(ProjectTaskStatus.NotSet.GetDisplayNameString());
        }
        await base.OnInitializedAsync();
    }
    protected internal async Task TaskChangedCallback(ProjectTaskViewModel viewModel)
    {
        string newStatus = viewModel.Status.GetDisplayNameString();
        if (viewModel.Id <= 0)
        {
            Project.Tasks.Add(viewModel);
            _tasksByStatus[newStatus].Add(viewModel);
        }
        else
        {
            string oldStatus = viewModel.PreviousState?.Status.GetDisplayNameString() ?? "";
            int index = _tasksByStatus[newStatus].FindIndex(t => t.Id == viewModel.Id);
            //not found in old status, we moved the task
            if (!string.IsNullOrEmpty(oldStatus) && index == -1)
            {
                var oldTask = _tasksByStatus[oldStatus].FirstOrDefault(x => x.Id == viewModel.Id);
                _tasksByStatus[oldStatus].Remove(oldTask);
                Project.Tasks.Remove(oldTask);
                _tasksByStatus[newStatus].Add(viewModel);
            }
            else if(!string.IsNullOrEmpty(oldStatus))
            {
                _tasksByStatus[oldStatus][index] = viewModel;
            }
            else
            {
                throw new Exception("Error adding task to dictionary. Contact a dev.");
            }
        }
        _isTaskEditOpen = false;
        await InvokeAsync(StateHasChanged);
    }
    internal async Task HandleSaveClick(MouseEventArgs args)
    {
        await _client.Save(Project);
        await SaveCallback.Invoke(Project);
    }
    internal async Task OpenProjectTask(ProjectTaskViewModel viewModel)
    {
        _focusedTask = viewModel;
        viewModel.PreviousState = new ProjectTaskViewModel();

        viewModel.PreviousState.Status = viewModel.Status;
        viewModel.PreviousState.Title = viewModel.Title;
        viewModel.PreviousState.Description = viewModel.Description;
        viewModel.PreviousState.Id = viewModel.Id;

        _isTaskEditOpen = true;
    }
    internal async Task CloseTaskEditForm()
    {
        _focusedTask = null;
        _isTaskEditOpen = false;
        await InvokeAsync(StateHasChanged);
    }
    internal async Task HandleTaskAdd(MouseEventArgs args)
    {
        _isTaskEditOpen = true;
        _focusedTask = new ProjectTaskViewModel();
        await InvokeAsync(StateHasChanged);
    }
}
